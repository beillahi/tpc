(declare-sort St)
(declare-sort Loc)
(declare-sort Rec)
(declare-sort Id)
(declare-sort Str)
(declare-fun G_s (St St) Bool)
(declare-fun G_d (St St) Bool)
(declare-fun G_w (St St) Bool)
(declare-fun R (St St) Bool)
(declare-fun IIr (St St St) Bool)
(declare-fun Rl (St St St) Bool)
(declare-fun IIc (St St St) Bool)
(declare-fun Rc (St St St) Bool)
(declare-fun in-dom (Loc St) Bool)
(declare-fun flush (St St St) Bool)
(declare-fun value (St Loc) Rec)
(declare-fun id (Rec) Id)
(declare-fun cbal (Rec) Int)
(declare-fun I (St) Bool)
(declare-fun user () Rec)
(declare-fun u_id () Id)
(declare-fun amt () Int)
(declare-fun Q3 (St St) Bool)
(declare-fun Q2 (St St) Bool)
(declare-fun U0 (St St St) Bool)
(declare-fun Q4 (St St) Bool)
(declare-fun Q5 (St St) Bool)
(declare-fun cstableQ5 () Bool)
(declare-fun soundG_w () Bool)

;; Domain and empty-state definitions
(define-fun dom-eq ((st1 St)(st2 St)) Bool
  (forall ((l Loc)) (= (in-dom l st1) (in-dom l st2))))
(define-fun empty-st ((st St)) Bool
  (forall ((l Loc)) (not (in-dom l st))))

;; Flush definition and useful theorems
; (assert (forall ((st0 St) (st1 St)(st2 St)(l Loc))
;   (! (=> (flush st0 st1 st2)
;          (= (in-dom l st2)
;             (or (in-dom l st0) (in-dom l st1)))) 
;    :pattern ())))
; (assert (forall ((st0 St) (st1 St)(st2 St)(l Loc))
;   (! (=> (flush st0 st1 st2)
;          (let ((a!1 (=> (in-dom l st1)
;                         (= (value st2 l) (value st1 l)))))
;            (ite (in-dom l st0)
;                 (= (value st2 l) (value st0 l))
;                 a!1)))
;   :pattern () )))
(assert (forall ((st0 St)(st1 St)(st2 St)(l Loc))
          (= (flush st0 st1 st2)
             (and (= (in-dom l st2)
                     (or (in-dom l st0) (in-dom l st1))) 
                  (let ((a!1 (=> (in-dom l st1)
                                 (= (value st2 l) (value st1 l)))))
                    (ite (in-dom l st0)
                         (= (value st2 l) (value st0 l))
                         a!1))) )))
(assert (forall ((st0 St) (st1 St)(st2 St))
  (=> (and (empty-st st0) (flush st0 st1 st2))
      (= st1 st2))))
(assert (forall ((st0 St)(st1 St)(st2 St)(st3 St)) 
          (=> (and (flush st0 st1 st2) (flush st0 st1 st3))
              (= st2 st3))))
;; Value axiom - Extensional equality of states.
(assert (forall ((st1 St)(st2 St)) 
          (=> (and (dom-eq st1 st2) 
                   (forall ((l Loc))
                      (=> (and (in-dom l st1) (in-dom l st2))
                          (= (value st1 l) (value st2 l)))))
              (= st1 st2))))

(define-fun st-eq ((st1 St)(st2 St)) Bool
  (and (dom-eq st1 st2) 
       (forall ((l Loc))
          (=> (and (in-dom l st1) (in-dom l st2))
              (= (value st1 l) (value st2 l)))))
)

;; Basic axioms
; (assert (forall ((bv0 St) (bv1 Loc) (bv2 Loc))
;   (let ((a!1 (and (in-dom bv1 bv0)
;                   (in-dom bv2 bv0)
;                   (= (id (value bv0 bv1)) (id (value bv0 bv2))))))
;     (=> a!1 (= bv1 bv2)))))
(assert (forall ((r1 Rec)(r2 Rec)) 
          (=> (= (id r1) (id r2)) (= r1 r2))))
(assert (forall ((st St)(l1 Loc)(l2 Loc)) 
          (=> (= (value st l1) (value st l2)) (= l1 l2))))

;; App spec
(assert (forall ((bv0 St) (bv1 St))
  (let ((a!1 (exists ((bv2 Loc))
               (let ((a!1 (forall ((bv3 Loc))
                            (=> (not (= bv3 bv2))
                                (= (value bv1 bv3) (value bv0 bv3))))))
                 (and (in-dom bv2 bv0)
                      (dom-eq bv1 bv0)
                      (= (id (value bv1 bv2)) (id (value bv0 bv2)))
                      (>= (cbal (value bv1 bv2)) 0)
                      a!1)))))
    (= (G_d bv0 bv1) a!1))))
(assert (forall ((bv0 St) (bv1 St))
  (let ((a!1 (exists ((bv2 Loc))
               (let ((a!1 (forall ((bv3 Loc))
                            (=> (not (= bv3 bv2))
                                (= (value bv1 bv3) (value bv0 bv3))))))
                 (and (in-dom bv2 bv0)
                      (dom-eq bv1 bv0)
                      (= (id (value bv1 bv2)) (id (value bv0 bv2)))
                      (>= (cbal (value bv1 bv2)) 0)
                      a!1)))))
    (= (G_s bv0 bv1) a!1))))
(assert (forall ((bv0 St) (bv1 St))
  (let ((a!0 (and (dom-eq bv0 bv1)
                  (forall ((bv3 Loc))
                    (=> (in-dom bv3 bv0)
                        (and (in-dom bv3 bv1)
                             (= (value bv1 bv3) (value bv0 bv3)))))))
        (a!1 (exists ((bv2 Loc))
               (let ((a!2 (forall ((bv3 Loc))
                            (=> (in-dom bv3 bv0)
                                (and (in-dom bv3 bv1)
                                     (= (value bv1 bv3) (value bv0 bv3))))))
                     (a!1 (forall ((bv3 Loc))
                            (=> (and (not (= bv3 bv2)) (in-dom bv3 bv0))
                                (and (in-dom bv3 bv1)
                                     (= (value bv1 bv3) (value bv0 bv3)))))))
                 (and (in-dom bv2 bv0)
                      (dom-eq bv1 bv0)
                      (= (id (value bv1 bv2)) (id (value bv0 bv2)))
                      (>= (cbal (value bv1 bv2)) 0)
                      a!1
;                     a!2
                      )))))
    (= (G_w bv0 bv1) a!1))))
(assert (forall ((bv0 St))
  (let ((a!1 (forall ((bv1 Loc))
               (let ((a!1 (>= (cbal (value bv0 bv1)) 0)))
                 (=> (in-dom bv1 bv0) a!1)))))
    (= (I bv0) a!1))))
(assert (forall ((bv0 St) (bv1 St))
  (= (R bv0 bv1) (or 
                     (G_w bv0 bv1) 
                     (G_d bv0 bv1) 
                     (G_s bv0 bv1)
                     ))))
(assert (forall ((bv0 St) (bv1 St) (bv2 St))
  (= (Rl bv0 bv1 bv2) (and (R bv1 bv2) (IIr bv0 bv1 bv2)))))
(assert (forall ((bv0 St) (bv1 St) (bv2 St))
  (= (Rc bv0 bv1 bv2) (and (R bv1 bv2) (IIc bv0 bv1 bv2)))))
;; 
(assert (forall ((st0 St) (st1 St))
  (= (Q2 st0 st1) (and  (let ((a!1 (exists ((l Loc)
                                            (st2 St))
                                     (and (flush st0 st1 st2)
                                          (in-dom l st2)
                                          (= (value st2 l) user)
                                     ))))
                          (and (empty-st st0) 
                               (I st1) 
                               (= (id user) u_id) 
                               a!1
                               ))
                       (not (>= (cbal user) amt))
                  ))))
(assert (forall ((st0 St) (st1 St) (st2 St))
  (= (U0 st0 st1 st2)
     (exists ((st3 St)) 
        (and (flush st1 st0 st3)
             (forall ((l Loc))
               (let ((a!1 true)
                     (a!2 (= (id (value st3 l)) u_id))
                     (a!4 (= (id (value st2 l)) (id (value st3 l))))
                     (a!8 (ite (in-dom l st1)
                               (and (in-dom l st2)
                                    (= (value st2 l) (value st1 l)))
                               (not (in-dom l st2)))))
               (let ((a!3 (and (in-dom l st3) a!1 a!2))
                     (a!7 (and (in-dom l st2)
                               a!4
                               (= (cbal (value st2 l)) (- (cbal user) amt))
                               )))
                 (ite a!3 a!7 a!8)))))))))
(assert (forall ((st0 St) (st1 St))
  (= (Q3 st0 st1) (and  (let ((a!1 (exists ((l Loc)(st2 St))
                                     (and (flush st0 st1 st2)
                                          (in-dom l st2)
                                          (= (value st2 l) user)))))
                          (and (empty-st st0) (I st1) (= (id user) u_id) a!1))
                       (>= (cbal user) amt)))))
(assert (forall ((st0 St) (st1 St))
  (= (Q4 st0 st1) 
     (exists ((st2 St)) 
       (and (Q3 st2 st1) 
            (U0 st1 st2 st0))))))
;; Q5 captures both the branches.
(assert (forall ((st0 St) (st1 St)) (= (Q5 st0 st1) 
                                        (or (Q4 st0 st1) 
                                            (Q2 st0 st1)))))
;; cstability of Q5
(assert (let ((a!1 (forall ((bv0 St) (bv1 St) (bv2 St))
             (=> (and (Q5 bv0 bv1) (Rc bv0 bv1 bv2)) (Q5 bv0 bv2)))))
  (= cstableQ5 a!1)))
(assert (let ((a!1 (forall ((bv0 St) (bv1 St) (bv2 St))
             (=> (and (Q5 bv0 bv1) (st-eq bv1 bv2)) (Q5 bv0 bv2)))))
  (= cstableQ5 a!1)))
(assert (not cstableQ5))
(check-sat)

; (assert (not (forall ((st1 St)(st2 St)(st21 St))
;                 (=> (and (exists ((st3 St)) (flush st1 st2 st3))
;                          (st-eq st2 st21))
;                     (exists ((st3 St)) (flush st1 st21 st3))))))
; (check-sat)

;; soundness of G_w
; (assert (not (forall ((st0 St)(st1 St)) 
;                 (=> (and (I st0) (R st0 st1)) (I st1)))))
; (assert (= soundG_w (forall ((bv0 St) (bv1 St)(bv2 St))
;                        (=> (and (Q5 bv0 bv1) (flush bv0 bv1 bv2)) (G_w bv2 bv1)))))
; (assert (not soundG_w))

; (assert (not (forall ((st1 St)(st2 St)) 
;                 (=> (G_w st1 st2) (st-eq st1 st2)))))
; (check-sat)

; (assert (not (forall ((st1 St)(st2 St)(st3 St)(st21 St)(st31 St)) 
;                 (=> (and (flush st1 st2 st3) 
;                          (G_w st2 st21) 
;                          (flush st1 st21 st31)) 
;                     (st-eq st3 st31)))))
; (check-sat)
